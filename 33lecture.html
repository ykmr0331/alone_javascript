<!--ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ33강 객체기본ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ-->
<script>
  const array = [100, 20, '문자열', true, function () {}, () => {}] //배열  
  console.log(array[0])
  array[0] = 200 //배열에 있는 어떤 값을 교체할 때 이렇게 해라
  console.log(array[0])
  /*배열 내부의 요소에 접근할 떄 대괄호 내부를 열고 내부에 index를 입력했음
  console.log(array[0])
이런식으로*/

  const object = {
  /*키:값,    일반적으로 키에는 '식별자'를 사용한다, 식별자의 기본적인 조건은 숫자로 시작하지 않는다
                기호는 $,_만 포함한다. */
    name: '구름',
    age: 7
  }
  console.log(object['name'])
  console.log(object.name)
  object.age = 1  // 이것도 객체에 있는 어떤 값을 교체할 떄
  console.log(object.age)

/*이렇게 나옴

100 
20
구름
구름
7

*/
</script>
<!--속성과 메소드에 대해ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ-->

<script>
  //속성(property)
const dog = {
  name: '구름',
  age: 7,
  bark: function () {
    console.log(`${dog.name}이/가 짖습니다!`)
  },
  sleep: () => {
    console.log(`${dog.name}이/가 잡니다!`)
  }
  //화살표 함수로 메소드 만들어보기
}

dog.bark()
dog.sleep()
</script>

<!--this 키워드ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ-->
<!--익명함수와 화살표함수의 차이가 발생하면서 시작-->  
<!--
!!!!!!!!!!!!!!!익명함수에서는 메서드 내부에서 디스 사용하면 자기자신을 나태난다!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!하지만 화살표 함수에서는 this라는 객체가 따로 연결되지 않습니다.!!!!!!!!!!!!!!

화살표 함수 내부에서 this를 출력하면 윈도우라는 거대한 객체가 출력되는 모습을 볼 수 있다.

익명함수는 객체를 연결 binding해주는데 
화살표 함수는 객체를 binding해주지 않는다.

그래서   -->

<script>
  //속성(property)
  //메서드(method)
const dog = {
  name: '구름',
  age: 7,
  bark: function () {
    console.log(`${dog.name}이/가 짖습니다!`)
    console.log(`${this.name}이/가 짖습니다!`)
    console.log(this)
  },
  sleep: () => {
    console.log(`${dog.name}이/가 잡니다!`)
    console.log(this)
  }
}

dog.bark()
dog.sleep()

/*

구름이/가 짖습니다!
구름이/가 짖습니다!
{name: '구름', age: 7, bark: ƒ, sleep: ƒ}
구름이/가 잡니다!
Window {window: Window, self: Window, document: document, name: '', location: Location, …}

*/
</script>




